# Default values for jaeger.
# This is a YAML-formatted file.
# Jaeger values are grouped by component. Cassandra values override subchart values

enabled: false

provisionDataStore:
  cassandra: true
  elasticsearch: false
  kafka: false

tag: 1.6.12-am3

nameOverride: ""
fullnameOverride: "aspen-mesh-jaeger"

storage:
  # allowed values (cassandra, elasticsearch)
  type: cassandra
  cassandra:
    host: cassandra
    port: 9042
    tls:
      enabled: false
      secretName: cassandra-tls-secret
    user: user
    usePassword: true
    password: password
    keyspace: jaeger_v1_test
    ## Use existing secret (ignores previous password)
    # existingSecret:

# Begin: Override values on the Cassandra subchart to customize for Jaeger
cassandra:
  persistence:
    enabled: true
    size: 10Gi
  config:
    cluster_name: jaeger
    seed_size: 1
    dc_name: dc1
    rack_name: rack1
    endpoint_snitch: GossipingPropertyFileSnitch
  cluster_size: 3
  affinity:
    podAntiAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
      - labelSelector:
          matchExpressions:
            - key: app
              operator: In
              values:
              - cassandra
        topologyKey: "kubernetes.io/hostname"
  exporter:
    enabled: true
    servicemonitor: false

# End: Override values on the Cassandra subchart to customize for Jaeger

# Begin: Default values for the various components of Jaeger
# This chart has been based on the Kubernetes integration found in the following repo:
# https://github.com/jaegertracing/jaeger-kubernetes/blob/master/production/jaeger-production-template.yml
#
# This is the jaeger-cassandra-schema Job which sets up the Cassandra schema for
# use by Jaeger
schema:
  annotations:
    "helm.sh/hook": post-install,post-upgrade
    "helm.sh/hook-delete-policy": hook-succeeded
  image: jaeger-cassandra-schema
  pullPolicy: IfNotPresent
  # Acceptable values are test and prod. Default is for production use.
  mode: prod
  resources: {}
    # limits:
    #   cpu: 500m
    #   memory: 512Mi
    # requests:
    #   cpu: 256m
    #   memory: 128Mi
  serviceAccount:
    create: true
    name:
  ## Additional pod labels
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  podLabels: {}
  ## Deadline for cassandra schema creation job
  activeDeadlineSeconds: 300
  ## Trace retention period. 691200 seconds = 8 days
  traceTtl: 691200
  # dependenciesTtl: 0

ingester:
  enabled: false
  podSecurityContext: {}
  securityContext: {}
  annotations: {}
  image: jaeger-ingester
  pullPolicy: IfNotPresent
  dnsPolicy: ClusterFirst
  cmdlineParams: {}
  replicaCount: 1
  autoscaling:
    enabled: false
    minReplicas: 2
    maxReplicas: 10
    # targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80
  service:
    annotations: {}
    # List of IP ranges that are allowed to access the load balancer (if supported)
    loadBalancerSourceRanges: []
    type: ClusterIP
  resources: {}
    # limits:
    #   cpu: 1
    #   memory: 1Gi
    # requests:
    #   cpu: 500m
    #   memory: 512Mi
  serviceAccount:
    create: true
    name:
  nodeSelector: {}
  tolerations: []
  affinity: {}
  podAnnotations: {}
  ## Additional pod labels
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  podLabels: {}
  extraSecretMounts: []
  extraConfigmapMounts: []

agent:
  podSecurityContext: {}
  securityContext: {}
  enabled: false
  annotations: {}
  image: jaeger-agent
  pullPolicy: IfNotPresent
  cmdlineParams: {}
  daemonset:
    useHostPort: false
  service:
    annotations: {}
    # List of IP ranges that are allowed to access the load balancer (if supported)
    loadBalancerSourceRanges: []
    type: ClusterIP
    # zipkinThriftPort :accept zipkin.thrift over compact thrift protocol
    zipkinThriftPort: 5775
    # compactPort: accept jaeger.thrift over compact thrift protocol
    compactPort: 6831
    # binaryPort: accept jaeger.thrift over binary thrift protocol
    binaryPort: 6832
    # samplingPort: (HTTP) serve configs, sampling strategies
    samplingPort: 5778
  resources: {}
    # limits:
    #   cpu: 500m
    #   memory: 512Mi
    # requests:
    #   cpu: 256m
    #   memory: 128Mi
  serviceAccount:
    create: true
    name:
  nodeSelector: {}
  tolerations: []
  affinity: {}
  podAnnotations: {}
  ## Additional pod labels
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  podLabels: {}
  extraSecretMounts: []
  # - name: jaeger-tls
  #   mountPath: /tls
  #   subPath: ""
  #   secretName: jaeger-tls
  #   readOnly: true
  extraConfigmapMounts: []
  # - name: jaeger-config
  #   mountPath: /config
  #   subPath: ""
  #   configMap: jaeger-config
  #   readOnly: true
  useHostNetwork: false
  dnsPolicy: ClusterFirst

collector:
  podSecurityContext: {}
  securityContext: {}
  enabled: true
  annotations: {}
  image: jaeger-collector
  pullPolicy: IfNotPresent
  dnsPolicy: ClusterFirst
  cmdlineParams: {}
  replicaCount: 1
  autoscaling:
    enabled: false
    minReplicas: 2
    maxReplicas: 10
    # targetCPUUtilizationPercentage: 80
    # targetMemoryUtilizationPercentage: 80
  service:
    annotations: {}
    # List of IP ranges that are allowed to access the load balancer (if supported)
    loadBalancerSourceRanges: []
    type: ClusterIP
    grpcPort: 14250
    # tchannelPort: used by jaeger-agent to send spans in jaeger.thrift format
    tchannelPort: 14267
    # httpPort: can accept spans directly from clients in jaeger.thrift format
    httpPort: 14268
    # can accept Zipkin spans in JSON or Thrift
    zipkinPort: 9411
  resources: {}
    # limits:
    #   cpu: 1
    #   memory: 1Gi
    # requests:
    #   cpu: 500m
    #   memory: 512Mi
  serviceAccount:
    create: true
    name:
  nodeSelector: {}
  tolerations: []
  affinity: {}
  podAnnotations: {}
  ## Additional pod labels
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  podLabels: {}
  extraSecretMounts: []
  # - name: jaeger-tls
  #   mountPath: /tls
  #   subPath: ""
  #   secretName: jaeger-tls
  #   readOnly: true
  extraConfigmapMounts: []
  # - name: jaeger-config
  #   mountPath: /config
  #   subPath: ""
  #   configMap: jaeger-config
  #   readOnly: true
  # samplingConfig: |-
  #   {
  #     "service_strategies": [
  #       {
  #         "service": "foo",
  #         "type": "probabilistic",
  #         "param": 0.8,
  #         "operation_strategies": [
  #           {
  #             "operation": "op1",
  #             "type": "probabilistic",
  #             "param": 0.2
  #           },
  #           {
  #             "operation": "op2",
  #             "type": "probabilistic",
  #             "param": 0.4
  #           }
  #         ]
  #       },
  #       {
  #         "service": "bar",
  #         "type": "ratelimiting",
  #         "param": 5
  #       }
  #     ],
  #     "default_strategy": {
  #       "type": "probabilistic",
  #       "param": 1
  #     }
  #   }

query:
  enabled: true
  basePath: /tracing
  podSecurityContext: {}
  securityContext: {}
  agentSidecar:
    enabled: true
  annotations: {}
  image: jaeger-query
  pullPolicy: IfNotPresent
  dnsPolicy: ClusterFirst
  cmdlineParams: {}
  replicaCount: 1
  service:
    annotations: {}
    type: ClusterIP
    # List of IP ranges that are allowed to access the load balancer (if supported)
    loadBalancerSourceRanges: []
    port: 80
  ingress:
    enabled: false
    annotations: {}
    # Used to create an Ingress record.
    # hosts:
    #   - chart-example.local
    # annotations:
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    # tls:
      # Secrets must be manually created in the namespace.
      # - secretName: chart-example-tls
      #   hosts:
      #     - chart-example.local
  resources: {}
    # limits:
    #   cpu: 500m
    #   memory: 512Mi
    # requests:
    #    cpu: 256m
    #    memory: 128Mi
  serviceAccount:
    create: true
    name:
  nodeSelector: {}
  tolerations: []
  affinity: {}
  podAnnotations: {}
  ## Additional pod labels
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  podLabels: {}
  extraConfigmapMounts: []
  # - name: jaeger-config
  #   mountPath: /config
  #   subPath: ""
  #   configMap: jaeger-config
  #   readOnly: true

spark:
  enabled: false
  annotations: {}
  image: spark-dependencies
  tag: latest
  pullPolicy: Always
  schedule: "49 23 * * *"
  successfulJobsHistoryLimit: 5
  failedJobsHistoryLimit: 5
  resources: {}
    # limits:
    #   cpu: 500m
    #   memory: 512Mi
    # requests:
    #   cpu: 256m
    #   memory: 128Mi
  serviceAccount:
    create: true
    name:
  nodeSelector: {}
  tolerations: []
  affinity: {}
  ## Additional pod labels
  ## ref: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/
  podLabels: {}
# End: Default values for the various components of Jaeger

hotrod:
  enabled: false
  podSecurityContext: {}
  securityContext: {}
  replicaCount: 1
  image:
    repository: jaegertracing/example-hotrod
    pullPolicy: Always
  service:
    annotations: {}
    name: hotrod
    type: ClusterIP
    # List of IP ranges that are allowed to access the load balancer (if supported)
    loadBalancerSourceRanges: []
    port: 80
  ingress:
    enabled: false
    # Used to create Ingress record (should be used with service.type: ClusterIP).
    hosts:
      - chart-example.local
    annotations: {}
      # kubernetes.io/ingress.class: nginx
      # kubernetes.io/tls-acme: "true"
    tls:
      # Secrets must be manually created in the namespace.
      # - secretName: chart-example-tls
      #   hosts:
      #     - chart-example.local
  resources: {}
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user. This also increases chances charts run on environments with little
    # resources, such as Minikube. If you do want to specify resources, uncomment the following
    # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
    # limits:
    #   cpu: 100m
    #   memory: 128Mi
    # requests:
    #   cpu: 100m
    #   memory: 128Mi
  serviceAccount:
    create: true
    name:
  nodeSelector: {}
  tolerations: []
  affinity: {}
  tracing:
    host: null
    port: 6831
